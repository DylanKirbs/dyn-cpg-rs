# TODO & FIXMEs

## Empirical Data
- [x] Tree sitter
- [x] Graphviz
- [x] FFMPEG

## Compare each stage of the pipeline
- [x] File Changes / Edits
- [x] Merging dirty ranges
- [x] AST rehydration
- [x] CF pass
- [ ] DD pass (WIP needs to use CF edges)

## Interface

Streamline the internal API. Since the CPG is source aware, all we theoretically need to do is pass the new source to the CPG, and it should be able to handle to full incremental flow. Additionally, since most of the logic is implanted in CPG mutators, we can return metrics from those mutators to get more granular data on where time is being spent.

Some internals can use a bit of love, the incremental update pipeline is a huge 500 line function that can be refactored into smaller, more maintainable and testable pieces (again with metrics returned from each piece).

A bit more configurability (even if it's just at compile time) would be nice. For example, deciding how to tokenise the input for the Meyers Diff, using LCS instead of Meyers, disabling the CF or DD passes, etc.

- [ ] API -> `update(source) -> Metrics`
- [ ] Return metrics from mutators


## Database
- [ ] Integrate with a DBMS
- [ ] Test the performance with DB integration
  - I suspect that this may swing the tides of how the incremental updates perform compared to the full reparses

## Known Issues

- Control flow pass is not perfect, I can't handle switch statements and break/continue
- DF pass is independent of CF, so that needs to be addressed still

## Writup


1. Dependency propagation:
  - Even a 1-line edit can trigger re-parsing of a large subtree if other nodes depend on it. Visualize this with a dependency graph of parse nodes.
2. Distribution of speedups:
  - Plot a histogram/log histogram of speedups.
  - Highlight cases where incremental parsing is slower, even for small edits.
3. Correlation analysis:
  - edits_count, lines_per_edit → speedup
  - full_nodes or full_edges → incremental time

This will show quantitatively when incremental parsing is beneficial.

Case studies:
- Pick a few patches with speedup < 1 and dissect them.
- Explain why incremental parsing failed to outperform full parsing.

Guidelines for incremental parsing:
From the data, you can derive rough thresholds: e.g., incremental parsing shines for <10 edits, small files, or shallow dependency graphs.
