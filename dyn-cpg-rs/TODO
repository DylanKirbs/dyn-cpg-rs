# TODO & FIXMEs

## Empirical Data
- [x] Tree sitter
- [x] Graphviz
- [x] FFMPEG

## Compare each stage of the pipeline
- [x] File Changes / Edits
- [x] Merging dirty ranges
- [x] AST rehydration
- [x] CF pass
- [ ] DD pass (WIP needs to use CF edges)

## Interface

Streamline the internal API. Since the CPG is source aware, all we theoretically need to do is pass the new source to the CPG, and it should be able to handle to full incremental flow. Additionally, since most of the logic is implanted in CPG mutators, we can return metrics from those mutators to get more granular data on where time is being spent.

Some internals can use a bit of love, the incremental update pipeline is a huge 500 line function that can be refactored into smaller, more maintainable and testable pieces (again with metrics returned from each piece).

A bit more configurability (even if it's just at compile time) would be nice. For example, deciding how to tokenise the input for the Meyers Diff, using LCS instead of Meyers, disabling the CF or DD passes, etc.

- [ ] API -> `update(source) -> Metrics`
- [ ] Return metrics from mutators


## Database
- [ ] Integrate with a DBMS
- [ ] Test the performance with DB integration
  - I suspect that this may swing the tides of how the incremental updates perform compared to the full reparses

## Known Issues

- Control flow pass is not perfect, I can't handle switch statements and break/continue
- DF pass is independent of CF, so that needs to be addressed still